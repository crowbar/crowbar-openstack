# heat stack-create --poll -f application.yaml -P app_volume_id=$app_volume_id -P db_volume_id=$db_volume_id -P key_name=default -P flavor=d1.tiny oscm
heat_template_version: 2015-10-15

description: |
  # This is how you deploy the whole thing:
  # 1) Instantiate volumes.yaml as follows
  heat stack-create --poll -f volumes.yaml oscm

  # 2) Retrieve outputs from oscm:
  app_volume_id=$(heat output-show oscm app_volume_id | sed 's/"//g')
  db_volume_id=$(heat output-show oscm db_volume_id | sed 's/"//g')

  # 3) Create application stack:
  heat stack-create --poll -f application.yaml -P app_volume_id=$app_volume_id -P db_volume_id=$db_volume_id -P key_name=<your nova keypair's name> oscm



parameters:
  floating_network:
    type: string
    default: floating
    description: Network to draw Floating IPs from
  image:
    type: string
    default: sles12-docker
    description: Glance image to use for servers
  flavor:
    type: string
    default: oscm.small
    description: Nova flavor to use for servers
  key_name:
    type: string
    default: oscm
    description: SSH key to add to servers' /root/.ssh/authorized_keys
  app_volume_id:
    type: string
    description: The Cinder volume to attach to the application server
  db_volume_id:
    type: string
    description: The Cinder volume to attach to the database server

resources:

  ### Network infrastructure ###

  oscm_network:
    type: OS::Neutron::Net
    properties:
      name: oscm

  oscm_subnet:
    type: OS::Neutron::Subnet
    properties:
      cidr: 10.0.0.1/24
      name: oscm
      network:
        get_resource: oscm_network

  router:
    type: OS::Neutron::Router
    properties:
      external_gateway_info:
        network:
          get_param: floating_network


  router_interface:
    type: OS::Neutron::RouterInterface
    properties:
      router: { get_resource: router }
      subnet: { get_resource: oscm_subnet }

  allow_inbound:
    type: OS::Neutron::SecurityGroup
    properties:
      description: "Allow inbound SSH and HTTP traffic"
      name: oscm
      rules:
        - direction: ingress
          remote_ip_prefix: 0.0.0.0/0
          protocol: tcp
          port_range_min: 22
          port_range_max: 22
        - direction: ingress
          remote_ip_prefix: 0.0.0.0/0
          protocol: tcp
          port_range_min: 80
          port_range_max: 80
        - remote_ip_prefix: 0.0.0.0/0
          protocol: icmp
        - direction: ingress
          remote_ip_prefix: 0.0.0.0/0
          protocol: tcp
          port_range_min: 5000
          port_range_max: 5000
        - direction: egress
          remote_ip_prefix: 0.0.0.0/0
          protocol: tcp
          port_range_min: 5000
          port_range_max: 5000
        - direction: ingress
          remote_ip_prefix: 0.0.0.0/0
          protocol: tcp
          port_range_min: 8080
          port_range_max: 8080
        - direction: ingress
          remote_ip_prefix: 0.0.0.0/0
          protocol: tcp
          port_range_min: 8880
          port_range_max: 8880
        - direction: ingress
          remote_ip_prefix: 0.0.0.0/0
          protocol: tcp
          port_range_min: 8081
          port_range_max: 8081
        - direction: ingress
          remote_ip_prefix: 0.0.0.0/0
          protocol: tcp
          port_range_min: 8048
          port_range_max: 8048
        - direction: ingress
          remote_ip_prefix: 0.0.0.0/0
          protocol: tcp
          port_range_min: 8881
          port_range_max: 8881
        - direction: ingress
          remote_ip_prefix: 0.0.0.0/0
          protocol: tcp
          port_range_min: 8848
          port_range_max: 8848

  ### Servers ###

  appserver:
    type: OS::Nova::Server
    properties:
      name: appserver
      config_drive: true
      flavor: { get_param: flavor }
      image: { get_param: image }
      key_name: { get_param: key_name }
      networks:
        - port: { get_resource: port_appserver }

  port_appserver:
    type: OS::Neutron::Port
    properties:
      network:
        get_resource: oscm_network
      security_groups:
        - get_resource: allow_inbound

  ip_appserver:
    type: OS::Neutron::FloatingIP
    properties:
      port_id: { get_resource: port_appserver }
      floating_network:
        get_param: floating_network

  app_volume_attachment:
    type: OS::Cinder::VolumeAttachment
    properties:
      instance_uuid: { get_resource: appserver }
      volume_id: { get_param: app_volume_id }

  db_volume_attachment:
    type: OS::Cinder::VolumeAttachment
    properties:
      instance_uuid: { get_resource: appserver }
      volume_id: { get_param: db_volume_id }

outputs:
  # Retrieval after stack creation (presuming stack is named `mystack`):
  # heat output-show mystack ip_appserver
  ip_appserver:
    value:
      get_attr:
        - ip_appserver
        - floating_ip_address
