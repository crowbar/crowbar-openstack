# heat stack-create --poll -f application.yaml -P app_volume_id=$app_volume_id -P db_volume_id=$db_volume_id -P key_name=default -P flavor=d1.tiny oscm
heat_template_version: 2015-10-15

description: |
  # This is how you deploy the whole thing:
  # 1) Instantiate volumes.yaml as follows
  heat stack-create --poll -f volumes.yaml oscm

  # 2) Retrieve outputs from oscm:
  app_volume_id=$(heat output-show oscm app_volume_id | sed 's/"//g')
  db_volume_id=$(heat output-show oscm db_volume_id | sed 's/"//g')

  # 3) Create application stack:
  heat stack-create --poll -f application.yaml -P app_volume_id=$app_volume_id -P db_volume_id=$db_volume_id -P key_name=<your nova keypair's name> oscm



parameters:
  floating_network:
    type: string
    default: floating
    description: Network to draw Floating IPs from
  image:
    type: string
    default: sles12-docker
    description: Glance image to use for servers
  flavor:
    type: string
    default: oscm.medium
    description: Nova flavor to use for servers
  key_name:
    type: string
    default: oscm
    description: SSH key to add to servers' /root/.ssh/authorized_keys
  app_volume_id:
    type: string
    description: The Cinder volume to attach to the application server
  db_volume_id:
    type: string
    description: The Cinder volume to attach to the database server
  app_name:
    default: oscm
    description: The application name
    type: string
  http_proxy:
    default: ""
    type: string
    description: Http proxy
  https_proxy:
    default: ""
    type: string
    description: Https proxy
  registry_host:
    default: ""
    type: string
    description: Docker registry host
  registry_port:
    default: ""
    type: string
    description: Docker registry port
  registry_user:
    default: ""
    type: string
    description: Docker registry user
  registry_pwd:
    default: ""
    type: string
    hidden: true
    description: Docker registry password
  mail_address:
    default: ""
    type: string
  mail_host:
    default: ""
    type: string
  mail_password:
    default: ""
    type: string
  mail_user:
    default: oscm
    type: string
  mail_port:
    default: 25
    type: string
  mail_auth:
    default: false
    type: string
  mail_tls:
    default: false
    type: string
  keystone_user_pwd:
    default: oscm
    type: string
  keystone_user_name:
    default: oscm
    type: string
  keystone_url:
    default: ""
    type: string
  keystone_tenant_id:
    default: oscm
    type: string
  keystone_domain:
    default: default
    type: string
  oscm_image_name:
    default: oscm
    type: string
  app_image_name:
    default: app
    type: string
  db_image_name:
    default: db
    type: string
  ssl_path:
    default: ""
    type: string
  wait_condition_timeout:
    default: 1800
    type: number
  ssh_cert:
    default: ""
    type: string
  heat_host_cidr:
    default: ""
    type: string
  heat_port:
    default: 8004
    type: number

resources:

  ssl_wait_handle:
    type: OS::Heat::WaitConditionHandle

  ssl_wait_condition:
    type: OS::Heat::WaitCondition
    depends_on: appserver
    properties:
      handle: { get_resource: ssl_wait_handle }
      timeout: { get_param: wait_condition_timeout }

  db_password:
    type: OS::Heat::RandomString

  keystore_password:
    type: OS::Heat::RandomString

  as_admin_password:
    type: OS::Heat::RandomString

  ### Network infrastructure ###

  oscm_network:
    type: OS::Neutron::Net
    properties:
      name: oscm


  oscm_subnet:
    type: OS::Neutron::Subnet
    properties:
      cidr: 10.0.0.1/24
      name: oscm
      network:
        get_resource: oscm_network

  router:
    type: OS::Neutron::Router
    properties:
      external_gateway_info:
        network:
          get_param: floating_network


  router_interface:
    type: OS::Neutron::RouterInterface
    properties:
      router: { get_resource: router }
      subnet: { get_resource: oscm_subnet }

  allow_inbound:
    type: OS::Neutron::SecurityGroup
    properties:
      description: "Allow inbound SSH and HTTP traffic"
      name: oscm
      rules:
        - direction: ingress
          remote_ip_prefix: 0.0.0.0/0
          protocol: tcp
          port_range_min: 22
          port_range_max: 22
        - direction: ingress
          remote_ip_prefix: 0.0.0.0/0
          protocol: tcp
          port_range_min: 80
          port_range_max: 80
        - remote_ip_prefix: 0.0.0.0/0
          protocol: icmp
        - direction: ingress
          remote_ip_prefix: 0.0.0.0/0
          protocol: tcp
          port_range_min: { get_param: registry_port }
          port_range_max: { get_param: registry_port }
        - direction: egress
          remote_ip_prefix: 0.0.0.0/0
          protocol: tcp
          port_range_min: { get_param: registry_port }
          port_range_max: { get_param: registry_port }
        - direction: ingress
          remote_ip_prefix: 0.0.0.0/0
          protocol: tcp
          port_range_min: 8080
          port_range_max: 8080
        - direction: ingress
          remote_ip_prefix: 0.0.0.0/0
          protocol: tcp
          port_range_min: 8880
          port_range_max: 8880
        - direction: ingress
          remote_ip_prefix: 0.0.0.0/0
          protocol: tcp
          port_range_min: 8081
          port_range_max: 8081
        - direction: ingress
          remote_ip_prefix: 0.0.0.0/0
          protocol: tcp
          port_range_min: 8881
          port_range_max: 8881
        - direction: egress
          remote_ip_prefix: 0.0.0.0/0
          protocol: tcp
          port_range_min: { get_param: mail_port }
          port_range_max: { get_param: mail_port }
        - direction: ingress
          remote_ip_prefix: { get_param: heat_host_cidr }
          protocol: tcp
          port_range_min: { get_param: heat_port }
          port_range_max: { get_param: heat_port }
        - direction: egress
          remote_ip_prefix: { get_param: heat_host_cidr }
          protocol: tcp
          port_range_min: { get_param: heat_port }
          port_range_max: { get_param: heat_port }


  # Parameters that will be available to both user data scripts
  user_data_params:
    type: OS::Heat::SoftwareConfig
    properties:
      group: ungrouped
      config:
        str_replace:
          template: {get_file: user-data/write-config}
          params:
            $APP_VOLUME_DEV:
              list_join:
                - ""
                - - "/dev/disk/by-id/virtio-"
                  - { get_param: app_volume_id }
            $DB_VOLUME_DEV:
              list_join:
                - ""
                - - "/dev/disk/by-id/virtio-"
                  - { get_param: db_volume_id }
            $DB_PASSWORD: { get_attr: [ db_password, value ] }
            $KEYSTORE_PASSWORD: { get_attr: [ keystore_password, value ] }
            $AS_ADMIN_PASSWORD: { get_attr: [ as_admin_password, value ] }
            $APP_NAME: { get_param: app_name }
            $HTTP_PROXY: { get_param: http_proxy }
            $HTTPS_PROXY: { get_param: https_proxy }
            $REGISTRY_HOST: { get_param: registry_host }
            $REGISTRY_PORT: { get_param: registry_port }
            $REGISTRY_USER: { get_param: registry_user }
            $REGISTRY_PWD: { get_param: registry_pwd }
            $MAIL_ADDRESS: { get_param: mail_address }
            $MAIL_HOST: { get_param: mail_host }
            $MAIL_PASSWORD: { get_param: mail_password }
            $MAIL_USER: { get_param: mail_user }
            $MAIL_PORT: { get_param: mail_port }
            $MAIL_AUTH: { get_param: mail_auth }
            $MAIL_TLS: { get_param: mail_tls }
            $KEYSTONE_USER_PWD: { get_param: keystone_user_pwd }
            $KEYSTONE_USER_NAME: { get_param: keystone_user_name }
            $KEYSTONE_URL: { get_param: keystone_url }
            $KEYSTONE_TENANT_ID: { get_param: keystone_tenant_id }
            $KEYSTONE_DOMAIN: { get_param: keystone_domain }
            $OSCM_IMAGE_NAME: { get_param: oscm_image_name }
            $APP_IMAGE_NAME: { get_param: app_image_name }
            $DB_IMAGE_NAME: { get_param: db_image_name }
            $SSL_PATH: { get_param: ssl_path }
            $WAIT_CURL: { get_attr: [ ssl_wait_handle, curl_cli ] }
            $SSH_CERT: { get_param: ssh_cert }

  # User data payload for appserver
  userdata_appserver:
    type: OS::Heat::MultipartMime
    properties:
      parts:
        - config: {get_resource: user_data_params}
        - config: {get_file: user-data/deploy-oscmserver}


  ### Servers ###

  appserver:
    type: OS::Nova::Server
    properties:
      name: appserver
      config_drive: true
      flavor: { get_param: flavor }
      image: { get_param: image }
      key_name: { get_param: key_name }
      networks:
        - port: { get_resource: port_appserver }
      user_data_format: RAW
      user_data: { get_resource: userdata_appserver }

  port_appserver:
    type: OS::Neutron::Port
    properties:
      network:
        get_resource: oscm_network
      security_groups:
        - get_resource: allow_inbound

  ip_appserver:
    type: OS::Neutron::FloatingIP
    properties:
      port_id: { get_resource: port_appserver }
      floating_network:
        get_param: floating_network

  app_volume_attachment:
    type: OS::Cinder::VolumeAttachment
    properties:
      instance_uuid: { get_resource: appserver }
      volume_id: { get_param: app_volume_id }

  db_volume_attachment:
    type: OS::Cinder::VolumeAttachment
    properties:
      instance_uuid: { get_resource: appserver }
      volume_id: { get_param: db_volume_id }

outputs:
  # Retrieval after stack creation (presuming stack is named `mystack`):
  # heat output-show mystack ip_appserver
  ip_appserver:
    value:
      get_attr:
        - ip_appserver
        - floating_ip_address
